# install.packages("unmarked")
library(dplyr)
library(readr)
library(unmarked)
require(stats4)
require(parallel)

#### utilizziamo i dati relativi alle occasioni già elaborato
Datioccas <- read.csv("../Dati-elaborati/Dati-occasioni.csv", dec=",", sep=";", header = TRUE)
tail(Datioccas)


#### Inserire l'anno su cui si vuole effettuare l'analisi es. =="2014", "2015", ecc
anno_analisi <- "2018"
sessione_analisi <- "1"
anno_int <- Datioccas$Anno == anno_analisi
sessione_int <- Datioccas$sessione == sessione_analisi
Datioccas_ <- subset(Datioccas, anno_int & sessione_int)
orario_occasione_singola <- as.data.frame(t(select(Datioccas_, ALBA..A.T.)))

trappole_posizionate <- max(Datioccas_$trappole.posizionate)
# forzo il numero di trappole a 75
trappole_posizionate <- 75
numero_occasioni <- nrow(Datioccas_)

# forziamo 75 trappole
#trappole_posizionate <- 75
orario_occasione <- rbind(orario_occasione_singola[rep(1, trappole_posizionate), ])
orario_occasione <- as.matrix(orario_occasione)
rownames(orario_occasione) <- c(1:trappole_posizionate)

orario_occasione



#### ripetiamo gli step per quanto riguarda le precipitazioni
precip <- as.data.frame(t(select(Datioccas_, Precipitazioni)))
precipitazioni_occasione <- rbind(precip[rep(1, trappole_posizionate), ])
precipitazioni_occasione <- as.matrix(precipitazioni_occasione)
rownames(precipitazioni_occasione) <- c(1:trappole_posizionate)
tail(precipitazioni_occasione)


#### ripetiamo gli step per i dati relativi alle temperature
temp <- as.data.frame(t(select(Datioccas_, Temperatura.C)))
temperatura_occasione <- rbind(temp[rep(1, trappole_posizionate), ])
temperatura_occasione <- as.matrix(temperatura_occasione)
rownames(temperatura_occasione) <- c(1:trappole_posizionate)

tail(temperatura_occasione)

#### A questo punto selezionare il file detection histories relativo all'anno di studio interessato creato durante l'esecuzione dello script "Detection History catture"
occasioni_cattura <- read.csv(paste0("../Dati-detection-history/Detection-Anno_", anno_analisi, "_Sessione_", sessione_analisi, ".csv"), dec=",", sep=";") 
occasioni_cattura <- subset( occasioni_cattura, select = -ID_TRAP)

tail(occasioni_cattura)

# Verifichiamo che i dataframe abbiano le stesse dimensioni
dim(orario_occasione)
dim(precipitazioni_occasione)
dim(temperatura_occasione)
dim(occasioni_cattura)
#Creiamo a questo punto una lista che contenga i dati in oggetto
obs.covs <- list(
    orario_occasione = matrix(c(orario_occasione), nrow=trappole_posizionate, ncol=numero_occasioni, byrow=FALSE),
    temperatura_occasione = matrix(c(temperatura_occasione), nrow=trappole_posizionate, ncol=numero_occasioni, byrow=FALSE),
    precipitazioni_occasione = matrix(c(precipitazioni_occasione), nrow=trappole_posizionate, ncol=numero_occasioni, byrow=FALSE)
)
#obs.covs


dati.cov <- read.csv("../Dati-elaborati/Dati-cov.csv", dec=",", sep=";")# da leggere file csv relativo alle covariate
dati.cov <- dati.cov[1:trappole_posizionate,]

head(dati.cov)
str(dati.cov)


## UNMARKED DATA FRAME
# ?unmarkedFrameOccu
# uniamo le detection histories e le covariate in unico dataframe "unmarked" e lo chiamiamo blgr
# y = capture histories (specifiche per la sessione 1 o la sessione 2)
# siteCovs = dati.cov, uguali per le due sessioni
# obsCovs alba/tramonto, specifico per la sessione 1 o la sessione 2
blgr <- unmarkedFrameOccu(y = occasioni_cattura, siteCovs=dati.cov, obsCovs=obs.covs) 
summary(blgr)

# Possiamo calcolare la mediana e intervallo interquartile del diametro delle rocce
MDR <- apply(dati.cov[,1:3], 1, median)
IQR <- apply(dati.cov[,1:3], 1, IQR)
# trasformo i dati dell'esposizione
# trasformazione e successiva analisi dei dati di esposizione
Esp.tr <- vector("numeric", length(dati.cov$aspect_deg))
for (i in 1:length(dati.cov$aspect_deg)) {
  if (dati.cov$aspect_deg[i] > 180) Esp.tr[i] <- dati.cov$aspect_deg[i]-360 else Esp.tr[i] <- dati.cov$aspect_deg[i]
}
#hist(Esp.tr)


# raggruppo i dati delle specie vegetali dominanti, facendo soltanto 3 gruppi: graminacee, muschio, tutte le altre
specie_dominante <- as.character(dati.cov$dominant)
specie_dominante[specie_dominante != "Graminacee" & specie_dominante != "Muschio"]  <- "Other_sp"

dati.cov.interesse <- cbind(dati.cov, MDR, IQR, Esp.tr, specie_dominante)
dati.cov.interesse <- dati.cov.interesse[,c("slope_degr","n_species","Cop_Veg_2018_ottavi","MDR","IQR","Esp.tr","specie_dominante")]


head(dati.cov.interesse)

#### si può procedere a fare l'analisi esplorativa sul dataset dati.cov.interesse e standardizzare ottavi_veg2018 (vedi la funzione 'scale')

dati.cov.interesse$ott <- scale(dati.cov.interesse$Cop_Veg_2018_ottavi)
# outlier detection
boxplot(dati.cov.interesse$slope_degr, xlab="slope_degr")
boxplot(dati.cov.interesse$n_species, xlab="n_species")
boxplot(dati.cov.interesse$Cop_Veg_2018_ottavi,xlab="ottavi_veg2018")
boxplot(dati.cov.interesse$ott, xlab="ott")
boxplot(dati.cov.interesse$MDR, xlab="MDR")
boxplot(dati.cov.interesse$IQR, xlab="IQR")
boxplot(dati.cov.interesse$Esp.tr, xlab="Esp.tr")


# collinearità
library(ggcorrplot)
cor.matrix <- cor(na.omit(dati.cov.interesse[,c("slope_degr","n_species","MDR","IQR","Esp.tr","ott")]))
ggcorrplot(cor.matrix)
p.mat <- (cor.matrix > 0.7)
p.mat
ggcorrplot(cor.matrix,
           hc.order = TRUE, method = "circle",
           type = "lower", p.mat = p.mat
)

siteCovs(blgr) <- dati.cov.interesse
#
# controllo
summary(blgr)


####Da questo punto in poi inizio ad avere difficoltà, i miei dati sembrano variare molto rispetto gli originali del 2018. è possibile che sia dovuto ai dati delle temperature e precipitazioni che variano rispetto a quelli ricavati da Bianca nel 2018. Dato che io ho incrociato i dati direttamente in base l'orario stimato delle occasioni.
## BASE MODEL
#siteCovs(blgr)
fm.base <- occu(~orario_occasione + MDR + temperatura_occasione + precipitazioni_occasione
                ~slope_degr + I(slope_degr^2) +
                MDR + I(MDR^2) +
                IQR + I(IQR^2) +
               #ott + I(ott^2) +
                n_species + I(n_species^2) +
                Esp.tr + I(Esp.tr^2) +
                specie_dominante,
                blgr)
fm.base


# 
# INFORMATICA
#

clusterType <- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
clust <- try(makeCluster(getOption("cl.cores", 2), type = clusterType))
clusterEvalQ(clust, library(unmarked))
clusterEvalQ(clust,library(MuMIn))
clusterExport(clust, "blgr")
invisible(clusterCall(clust, "library", "stats4", character.only = TRUE))
library(MuMIn)
getAllTerms(fm.base)

#la funzione pdredge non si completa e di conseguenza non crea l'oggetto pdd2, utile a mostrare i risultati della selezione automatica. 
## qui avvia la procedura di selezione automatica, con dredge (come per modelli di regressione "normali")
## mettendo i vincoli sulla presenza del termine al quadrato e escludendo le variabili troppo correlate 
pdd2 <- pdredge(fm.base, clust,
                subset = (`psi(slope_degr)` | !`psi(I(slope_degr^2))`) &&
                 (`psi(MDR)` | !`psi(I(MDR^2))`) &&
                 (`psi(IQR)` | !`psi(I(IQR^2))`) &&
                 #('psi(ott)' | !'psi(I(ott^2))') &&
                 (`psi(n_species)` | !`psi(I(n_species^2))`) &&
                 (`psi(Esp.tr)` | !`psi(I(Esp.tr^2))`)&&
                 #`psi(specie_dominante)`,
                 #('p(MDR)' | ! 'p(orario_occasione)')&&
                 #('p(precipitazioni_occasione)'| ! 'p(temperatura_occasione)'),
                
                trace = 2, m.lim = c(1,NA))
#pdd2
save(pdd2, file="../pdd2_sessione1.RData", compress=FALSE)
load("../pdd2_sessione1.RData")


## risultati
## PLOTTATO I RISULTATI DELLA SELEZIONE AUTOMATICA
## grafico da riportare nei risultati

#ho notato che neanche lo script originale riesce ad elaborare il plot per la sessione 1
par(mfrow = c(1,1))
op <- par(mar = c(3,5,6,4), mfrow=c(1,1))
plot(pdd2, labAsExpr = TRUE)
par(op)


#non essendoci pdd2 non possiamo vedere i modelli
## VEDIAMO I RISULTATI DEL MODELLO MIGLIORE
summary(get.models(pdd2, 1)[[1]])
# riportare la tabella dei coefficienti
## PASSAGGIO DI MODEL AVERAGING: CONSIDERIAMO CONTEMPORANEAMENTE I MODELLI MIGLIORI CHE DIFFERISCONO TRA LORO
## DI POCO IN TERMINI DI AIC (deltaAIC < 2)
summary(model.avg(pdd2, subset = delta < 2))

## questa parte stima il numero di siti occupati ma non ci serve
# 
#s<-nrow(y)
#re <- ranef(get.models(pdd2, 1)[[1]])
#EBUP <- bup(re, stat="mode")
#CI <- confint(re, level=0.95)
#print("95 % EB interval on number sites occupied")
#rbind(s_occup = c(Estimate = sum(EBUP), colSums(CI)) )
#print("95 % EB interval on proportion of sites occupied")
#rbind(PAO = c(Estimate = sum(EBUP), colSums(CI))/s )
# If you compare this statistic to the back-tranformed estimate of psi you'll notice it is somewhat lower.  
# Conceptually this represents the proportion of the finite sample (41 in this case) of sites occupied, 
# whereas psi estimates the probability of occupancy from an infinite list of sites.


#sono riuscita ad eseguire i grafici utilizzando occu(), i grafici somigliano molto a quelli originali (script Pier)
best.mod <- (get.models(pdd2, 1)[[1]])
best.mod <- occu(~ MDR + temperatura_occasione
                 ~ MDR +
                   Esp.tr +
                   specie_dominante,
                 blgr)
# ?unmarkedFitOccu-class

# Predict abundance at specified covariate values.
newdat1 <- data.frame(MDR = mean(dati.cov.interesse$MDR),
                     Esp.tr = seq(min(dati.cov.interesse$Esp.tr), max(dati.cov.interesse$Esp.tr), length=100),
                     specie_dominante = "Graminacee")
newdat2 <- data.frame(MDR = mean(dati.cov.interesse$MDR),
                      Esp.tr = seq(min(dati.cov.interesse$Esp.tr), max(dati.cov.interesse$Esp.tr), length=100),
                      specie_dominante = "Muschio")
newdat3 <- data.frame(MDR = mean(dati.cov.interesse$MDR),
                      Esp.tr = seq(min(dati.cov.interesse$Esp.tr), max(dati.cov.interesse$Esp.tr), length=100),
                      specie_dominante = "Other_sp")
newdat <- rbind(newdat1,newdat2,newdat3)
Elambda <- predict(best.mod, type='state', newdata=newdat,
                   appendData=TRUE)
head(Elambda)
Elambda.logit <- Elambda
par(mfrow=c(1, 2))
with(subset(Elambda.logit,specie_dominante=="Graminacee"), {
  plot(Esp.tr, Predicted, xlab="Esposizione", type="l", # names = habitat,
       ylab="Probabilità di presenza", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(Esp.tr, Predicted+SE, lty=3, col="dark grey")
  # lines(Esp.tr, Predicted-SE, lty=3, col="dark grey")
  lines(Esp.tr, upper, lty=2, col="grey")
  lines(Esp.tr, lower, lty=2, col="grey")
})

# Predict abundance at specified covariate values.
newdat1 <- data.frame(MDR = seq(min(dati.cov.interesse$MDR), max(dati.cov.interesse$MDR), length=100),
                      Esp.tr = mean(dati.cov.interesse$Esp.tr),
                      specie_dominante = "Graminacee")
newdat2 <- data.frame(MDR = seq(min(dati.cov.interesse$MDR), max(dati.cov.interesse$MDR), length=100),
                      Esp.tr = mean(dati.cov.interesse$Esp.tr),
                      specie_dominante = "Muschio")
newdat3 <- data.frame(MDR = seq(min(dati.cov.interesse$MDR), max(dati.cov.interesse$MDR), length=100),
                      Esp.tr = mean(dati.cov.interesse$Esp.tr),
                      specie_dominante = "Other_sp")
newdat <- rbind(newdat1,newdat2,newdat3)
Elambda <- predict(best.mod, type='state', newdata=newdat,
                   appendData=TRUE)
head(Elambda)
Elambda.logit <- Elambda
with(subset(Elambda.logit,specie_dominante=="Graminacee"), {
  plot(MDR, Predicted, xlab="MDR", type="l", # names = habitat,
       ylab="Probabilità di presenza", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(MDR, Predicted+SE, lty=3, col="dark grey")
  # lines(MDR, Predicted-SE, lty=3, col="dark grey")
  lines(MDR, upper, lty=2, col="grey")
  lines(MDR, lower, lty=2, col="grey")
})


newdat1 <- data.frame(MDR = seq(min(dati.cov.interesse$MDR), max(dati.cov.interesse$MDR), length=100),
                      temperatura_occasione = mean(temperatura_occasione, na.rm=TRUE))
Elambda.det <- predict(best.mod, type='det', newdata=newdat1,
                   appendData=TRUE)
with(Elambda.det, {
  plot(MDR, Predicted, xlab="MDR", type="l", # names = habitat,
       ylab="Probabilità di cattura", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(MDR, Predicted+SE, lty=3, col="dark grey")
  # lines(MDR, Predicted-SE, lty=3, col="dark grey")
  lines(MDR, upper, lty=2, col="grey")
  lines(MDR, lower, lty=2, col="grey")
})
newdat1 <- data.frame(MDR = mean(dati.cov.interesse$MDR),
                      temperatura_occasione = seq(min(temperatura_occasione, na.rm=TRUE)), (max(temperatura_occasione, na.rm=TRUE)), length=100)
Elambda.det <- predict(best.mod, type='det', newdata=newdat1,
                       appendData=TRUE)
with(Elambda.det, {
  plot(temperatura_occasione, Predicted, xlab="Temperatura", type="l", # names = habitat,
       ylab="Probabilità di cattura", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(temperatura_occasione, Predicted+SE, lty=3, col="dark grey")
  # lines(temperatura_occasione, Predicted-SE, lty=3, col="dark grey")
  lines(temperatura_occasione, upper, lty=2, col="grey")
  lines(temperatura_occasione, lower, lty=2, col="grey")
})

#### gli altri grafici fatti nella sessione 2 dello script origninale, utilizzando di nuovo occu(), non potendo usare il modello pdd2. Nello script originale (di Pier) non riesce a produrre i grafici... ?
best.mod2 <- occu(~ n_species + temperatura_occasione
                  ~ slope_degr +
                   ott +
                  specie_dominante,
                 blgr)

newdat_1 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                     ott = seq(-1.433279, 2.485843, length=100),
                     slope_degr = mean(dati.cov.interesse$slope_degr),
                     specie_dominante = "Graminacee")
newdat_2 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                      ott = seq(-1.433279, 2.485843, length=100),
                      slope_degr = mean(dati.cov.interesse$slope_degr),
                      specie_dominante = "Muschio")
newdat_3 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                      ott = seq(-1.433279, 2.485843, length=100),
                      slope_degr = mean(dati.cov.interesse$slope_degr),
                      specie_dominante = "Other_sp")
newdata <- rbind(newdat_1,newdat_2,newdat_3)
Elambda_ <- predict(best.mod2, type='state', newdata=newdata,
                   appendData=TRUE)
head(Elambda_)
Elambda.logit_ <- Elambda_

par(mfrow=c(1, 3))

with(subset(Elambda.logit_,specie_dominante=="Graminacee"), {
  plot(ott, Predicted, xlab="Copertura vegetazionale", type="l", # names = habitat,
       ylab="Probabilità di presenza", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(Esp.tr, Predicted+SE, lty=3, col="dark grey")
  # lines(Esp.tr, Predicted-SE, lty=3, col="dark grey")
  lines(ott, upper, lty=2, col="grey")
  lines(ott, lower, lty=2, col="grey")
})


###questo grafico è sbagliato, non riesco a capire dove ho sbagliato 
newdat1_ <- data.frame(n_species = seq(0, 32, length=100),
                      ott = 0,
                      slope_degr = mean(dati.cov.interesse$slope_degr),
                      specie_dominante = "Graminacee")
newdat2_ <- data.frame(n_species = seq(0, 32, length=100),
                      ott = 0,
                      slope_degr = mean(dati.cov.interesse$slope_degr),
                      specie_dominante = "Muschio")
newdat3_ <- data.frame(n_species = seq(0, 32, length=100),
                      ott = 0,
                      slope_degr = mean(dati.cov.interesse$slope_degr),
                      specie_dominante = "Other_sp")
newdat_ <- rbind(newdat1_,newdat2_,newdat3_)
Elambda__ <- predict(best.mod2, type='state', newdata=newdat_,
                   appendData=TRUE)
head(Elambda__)
Elambda.logit__ <- Elambda__
with(subset(Elambda.logit__,specie_dominante=="Graminacee"), {
  plot(n_species, Predicted, xlab="Numero di specie vegetali", type="l", # names = habitat,
       ylab="Probabilità di presenza", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(MDR, Predicted+SE, lty=3, col="dark grey")
  # lines(MDR, Predicted-SE, lty=3, col="dark grey")
  lines(n_species, upper, lty=2, col="grey")
  lines(n_species, lower, lty=2, col="grey")
})

newda1 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                      ott = 0,
                      slope_degr = seq(min(dati.cov.interesse$slope_degr),max(dati.cov.interesse$slope_degr)),
                      specie_dominante = "Graminacee")
newda2 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                      ott = 0,
                      slope_degr = seq(min(dati.cov.interesse$slope_degr),max(dati.cov.interesse$slope_degr)),
                      specie_dominante = "Muschio")
newda3 <- data.frame(n_species = mean(dati.cov.interesse$n_species),
                      ott = 0,
                      slope_degr = seq(min(dati.cov.interesse$slope_degr),max(dati.cov.interesse$slope_degr)),
                      specie_dominante = "Other_sp")
newda <- rbind(newda1,newda2,newda3)
Elambd <- predict(best.mod2, type='state', newdata=newda,
                   appendData=TRUE)
head(Elambd)
Elambda.logt <- Elambd
with(subset(Elambda.logt,specie_dominante=="Graminacee"), {
  plot(slope_degr, Predicted, xlab="Inclinazione", type="l", # names = habitat,
       ylab="Probabilità di presenza", #ylim=c(-20, 40), # cex.names=0.7,
       cex.lab=0.7, cex.axis=0.7, lwd=2, col="red")
  # lines(MDR, Predicted+SE, lty=3, col="dark grey")
  # lines(MDR, Predicted-SE, lty=3, col="dark grey")
  lines(slope_degr, upper, lty=2, col="grey")
  lines(slope_degr, lower, lty=2, col="grey")
})